import{createDecoder as e,createVerifier as t,TokenError as r}from"fast-jwt";class s extends Error{constructor(e,t){super(t),this.code=e,this.name=this.constructor.name,this.code=e}}class n extends s{constructor(e){super(401,"Revoked token, reason: "+e),this.reason=e,this.reason=e}}class o extends s{constructor(e){super(401,"Invalid token, reason: "+e),this.reason=e,this.reason=e}}class a extends o{constructor(e,t){super(void 0!==e?"token must be of type '"+e+(void 0!==t?.typ?`' but is of type '${t.typ}.`:"."):"token must be a string or a buffer."),this.typ=e}}class i extends o{constructor(){super("token is malformed.")}}class c extends o{constructor(){super("token payload must be an object.")}}class u extends o{constructor(){super("token signature is invalid.")}}class d extends o{constructor(e){super(e.toLowerCase()),this.reason=e}}class l extends s{constructor(){super(401,"Credentials bad scheme")}}class p extends s{constructor(){super(401,"Credentials bad format")}}class f extends s{constructor(){super(401,"Credentials required")}}class h extends o{constructor(e){super(e.toLowerCase()),this.reason=e}}class y extends s{constructor(e){super(401,e.toLowerCase()),this.reason=e,this.reason=e}}var m=function(e,t,r){"string"==typeof t&&(t=t.split("."));"symbol"==typeof t&&(t=[t]);var s,n=t.pop();if(!n)return!1;for(;s=t.shift();)if(void 0===e[s]&&(e[s]={}),!(e=e[s])||"object"!=typeof e)return!1;return e[n]=r,!0};const w=/^Bearer$/i;function g(e){if("string"==typeof e||e instanceof Buffer)return function(e){return{type:"promise",content:(t,r)=>new Promise(t=>{t(e.content)})}}({type:"basic",content:e});if(e instanceof Promise||"AsyncFunction"===e.constructor.name||"GeneratorFunction"===e.constructor.name)return{type:"promise",content:e};if("function"==typeof e&&4===e.length)return t={type:"callback",content:e},{type:"promise",content:(e,r,s)=>new Promise((n,o)=>t.content(e,r,s,(e,t)=>e?o(e):t?n(t):o(new Error("secret couldn't be retrieved"))))};throw new Error("jwt: secret field can be of type: string | Buffer | Promise | Function(req, jwtheader, payload, cb(err, ?secret))");var t}const b=s=>{if(!s||0===Object.keys(s).length)throw new Error("options can't be missing or empty, has required fields: [secret, algorithms]");if(!s.algorithms)throw new Error("jwt: algorithms field can't be undefined, must be an array of type string: [string]");if(!Array.isArray(s.algorithms))throw new Error("jwt: algorithms field must be an array of type string: [string]");const o=s.userProperty||s.requestProperty||"user",b=s.resultProperty,k=null==s.credentialsRequired||s.credentialsRequired,v=g(s.secret);let x=null!=s.get_token;return async(g,P,j)=>{try{let r="";if("OPTIONS"===g.method&&g.headers.hasOwnProperty("access-control-request-headers")&&(e=>(e.headers["access-control-request-headers"]||"").split(",").map(e=>e.trim()).includes("authorization"))(g))return j();if(x)r=s.get_token(g);else if(g.headers&&g.headers.authorization){const e=g.headers&&g.headers.authorization.split(" ");if(2!==e.length)throw new p;{const t=e[0],s=e[1];if(!w.test(t)){if(k)throw new l;return j()}r=s}}if(!r){if(k)throw new f;return j()}let a=e({complete:!0})(r,{checkTyp:s.token_type});const i=t({key:async()=>await v.content(g,a.header,a.payload),complete:!0,allowedAud:s.audience,allowedIss:s.issuer}),c=await i(r);if(await((e,t)=>new Promise((r,n)=>{if(!s.is_revoked)return r(!1);s.is_revoked(e,t,(e,t)=>{if(e)return n(e);r(t)})}))(g,a.payload))throw new n("internal ruleset");b?m(P,b,c.payload):m(g,o,c.payload),j()}catch(e){switch(e.code){case r.codes.invalidType:return j(new a(s?.token_type,e.header));case r.codes.malformed:return j(new i);case r.codes.invalidPayload:return j(new c);case r.codes.invalidSignature:return j(new u);case r.codes.invalidClaimValue:return j(new d(e.message));case r.codes.expired:return j(new h(e.message));case r.codes.keyFetchingError:return j(new y(e.message));default:return j(e)}}}};export{b as JWT};
