Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fast-jwt");class r extends Error{constructor(e,r){super(r),this.code=e,this.name=this.constructor.name,this.code=e}}class t extends r{constructor(e){super(401,"Revoked token, reason: "+e),this.reason=e,this.reason=e}}class s extends r{constructor(e){super(401,"Invalid token, reason: "+e),this.reason=e,this.reason=e}}class o extends s{constructor(e,r){super(void 0!==e?"token must be of type '"+e+(void 0!==r?.typ?`' but is of type '${r.typ}.`:"."):"token must be a string or a buffer."),this.typ=e}}class n extends s{constructor(){super("token is malformed.")}}class a extends s{constructor(){super("token payload must be an object.")}}class i extends s{constructor(){super("token signature is invalid.")}}class c extends s{constructor(e){super(e.toLowerCase()),this.reason=e}}class u extends r{constructor(){super(401,"Credentials bad scheme")}}class d extends r{constructor(){super(401,"Credentials bad format")}}class l extends r{constructor(){super(401,"Credentials required")}}class p extends s{constructor(e){super(e.toLowerCase()),this.reason=e}}class f extends r{constructor(e){super(401,e.toLowerCase()),this.reason=e,this.reason=e}}var h=function(e,r,t){"string"==typeof r&&(r=r.split("."));"symbol"==typeof r&&(r=[r]);var s,o=r.pop();if(!o)return!1;for(;s=r.shift();)if(void 0===e[s]&&(e[s]={}),!(e=e[s])||"object"!=typeof e)return!1;return e[o]=t,!0};const y=/^Bearer$/i;function w(e){if("string"==typeof e||e instanceof Buffer)return function(e){return{type:"promise",content:(r,t)=>new Promise(r=>{r(e.content)})}}({type:"basic",content:e});if(e instanceof Promise||"AsyncFunction"===e.constructor.name||"GeneratorFunction"===e.constructor.name)return{type:"promise",content:e};if("function"==typeof e&&4===e.length)return r={type:"callback",content:e},{type:"promise",content:(e,t,s)=>new Promise((o,n)=>r.content(e,t,s,(e,r)=>e?n(e):r?o(r):n(new Error("secret couldn't be retrieved"))))};throw new Error("jwt: secret field can be of type: string | Buffer | Promise | Function(req, jwtheader, payload, cb(err, ?secret))");var r}exports.JWT=r=>{if(!r||0===Object.keys(r).length)throw new Error("options can't be missing or empty, has required fields: [secret, algorithms]");if(!r.algorithms)throw new Error("jwt: algorithms field can't be undefined, must be an array of type string: [string]");if(!Array.isArray(r.algorithms))throw new Error("jwt: algorithms field must be an array of type string: [string]");const s=r.userProperty||r.requestProperty||"user",m=r.resultProperty,k=null==r.credentialsRequired||r.credentialsRequired,g=w(r.secret);let b=null!=r.get_token;return async(w,v,x)=>{try{let o="";if("OPTIONS"===w.method&&w.headers.hasOwnProperty("access-control-request-headers")&&(e=>(e.headers["access-control-request-headers"]||"").split(",").map(e=>e.trim()).includes("authorization"))(w))return x();if(b)o=r.get_token(w);else if(w.headers&&w.headers.authorization){const e=w.headers&&w.headers.authorization.split(" ");if(2!==e.length)throw new d;{const r=e[0],t=e[1];if(!y.test(r)){if(k)throw new u;return x()}o=t}}if(!o){if(k)throw new l;return x()}let n=e.createDecoder({complete:!0})(o,{checkTyp:r.token_type});const a=e.createVerifier({key:async()=>await g.content(w,n.header,n.payload),complete:!0,allowedAud:r.audience,allowedIss:r.issuer}),i=await a(o);if(await((e,t)=>new Promise((s,o)=>{if(!r.is_revoked)return s(!1);r.is_revoked(e,t,(e,r)=>{if(e)return o(e);s(r)})}))(w,n.payload))throw new t("internal ruleset");m?h(v,m,i.payload):h(w,s,i.payload),x()}catch(t){switch(t.code){case e.TokenError.codes.invalidType:return x(new o(r?.token_type,t.header));case e.TokenError.codes.malformed:return x(new n);case e.TokenError.codes.invalidPayload:return x(new a);case e.TokenError.codes.invalidSignature:return x(new i);case e.TokenError.codes.invalidClaimValue:return x(new c(t.message));case e.TokenError.codes.expired:return x(new p(t.message));case e.TokenError.codes.keyFetchingError:return x(new f(t.message));default:return x(t)}}}};
